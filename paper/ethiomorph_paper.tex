\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts

\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{listings}
\usepackage{fontspec}

% Font configuration for Ethiopic support
\setmainfont{Times New Roman}[Ligatures=TeX]
\newfontfamily\ethiopicfont[
  Path=/Users/esubalew/Library/Fonts/,
  Script=Ethiopic
]{AbyssinicaSIL-Regular.ttf}
\newcommand{\geez}[1]{{\ethiopicfont #1}}

\lstset{
  basicstyle=\small\ttfamily,
  breaklines=true,
  frame=single,
  numbers=left,
  numberstyle=\tiny,
  xleftmargin=2em
}

\begin{document}

\title{EthioMorph: Technical Implementation of a Rule-Based Ge'ez Morphological Engine}

\author{
\IEEEauthorblockN{Esubalew Chekol}
\IEEEauthorblockA{
\textit{College of Technology and Built Environment} \\
\textit{Addis Ababa University} \\
NLP Course Project}
}

\maketitle

\begin{abstract}
Ge'ez verb conjugation follows strict patterns. Given a root like \geez{ቀተለ}, every form (perfective, imperfective, jussive, imperative) can be computed by rearranging vowels and attaching affixes. No dictionary lookup, no statistical model. Just rules.

This paper documents EthioMorph, a Python system that does exactly that. It handles all eight verb types that traditional Ge'ez grammar recognizes: \geez{ቀተለ}, \geez{ቀደሰ}, \geez{ባረከ}, \geez{ጦመረ}, \geez{ሴሰየ}, \geez{ክህለ}, \geez{ማሕረከ}, and \geez{ተንበለ}. The core trick: Ethiopic Unicode assigns consecutive codepoints to vowel forms, so changing a vowel is just arithmetic. The rest is template matching and a few special rules for laryngeal consonants.
\end{abstract}

\begin{IEEEkeywords}
Ge'ez, morphological analysis, NLP, Unicode processing, Semitic morphology, rule-based systems
\end{IEEEkeywords}

\section{Introduction}

EthioMorph is a Ge'ez conjugator that works from first principles. Not a lookup table with thousands of pre-stored forms, and not a neural network trained on text. Just the rules, written in code.

Why is this even possible? Because Ge'ez is regular. The same root (\geez{ቀተለ}, meaning ``kill'') always conjugates the same way. There are eight verb types and maybe a dozen special cases for guttural consonants. Once you encode those rules, you can generate or analyze any verb.

\subsection{What the System Does}

Ge'ez verbs have two parts: a consonant root (usually 3 letters) and a vowel pattern. The root carries meaning, the pattern carries grammar.

Take \textbf{q-t-l} (\geez{ቀተለ}, ``kill''). Same three consonants, different vowels:

\begin{align*}
\text{q-t-l} + \text{[1-1-1]} &\rightarrow \text{\geez{ቀተለ}} \text{ (past: ``he killed'')} \\
\text{q-t-l} + \text{[yi-1-6-6]} &\rightarrow \text{\geez{ይቅትል}} \text{ (present: ``he kills'')}
\end{align*}

EthioMorph does this in both directions:

\textbf{Analysis}: \geez{ይቀትሉ} $\rightarrow$ root: \geez{ቀተለ}, tense: imperfective, subject: 3rd plural masculine

\textbf{Generation}: (\geez{ቀተለ}, imperfective, 3PM) $\rightarrow$ \geez{ይቀትሉ}

\section{Unicode Mathematics for Ethiopic}

\subsection{The Ethiopic Block Structure}

The Ethiopic Unicode block (U+1200–U+137F) organizes characters in a systematic pattern. Each consonant has 7 forms representing vowel variations:

\begin{table}[h]
\centering
\caption{Unicode Pattern for Consonant \geez{ቀ} (qäf)}
\begin{tabular}{cccc}
\toprule
Order & Unicode & Character & Vowel \\
\midrule
1 & U+1240 & \geez{ቀ} & ä (schwa) \\
2 & U+1241 & \geez{ቁ} & u \\
3 & U+1242 & \geez{ቂ} & i \\
4 & U+1243 & \geez{ቃ} & a \\
5 & U+1244 & \geez{ቄ} & e \\
6 & U+1245 & \geez{ቅ} & (none) \\
7 & U+1246 & \geez{ቆ} & o \\
\bottomrule
\end{tabular}
\label{tab:unicode}
\end{table}

\subsection{Vowel Arithmetic}

Since vowel forms are consecutive in Unicode, you can do math on them:

\begin{equation}
\text{order}(c) = ((c - \text{base\_offset}) \mod 8) + 1
\end{equation}

\begin{equation}
\text{base}(c) = c - (\text{order}(c) - 1)
\end{equation}

To change a vowel:

\begin{equation}
\text{revowelize}(\text{base}, \text{order}) = \text{base} + (\text{order} - 1)
\end{equation}

\textbf{Implementation:}
\begin{lstlisting}[language=Python]
def get_vowel_order(char):
    """Extract vowel order (1-7) from character."""
    return ORDER_MAP.get(char, 1)

def devowelize(char):
    """Return base consonant (1st order form)."""
    return DEVOWELIZATION_MAP.get(char, char)

def get_char_by_order(base, order):
    """Apply vowel order to base consonant."""
    return REVOWELIZATION_MAP.get((base, order), base)
\end{lstlisting}

\textbf{Example transformation:}
\begin{align*}
\text{devowelize}(\text{\geez{ቃ}}) &= \text{\geez{ቀ}} \\
\text{get\_vowel\_order}(\text{\geez{ቃ}}) &= 4 \\
\text{get\_char\_by\_order}(\text{\geez{ቀ}}, 6) &= \text{\geez{ቅ}}
\end{align*}

\section{The C1-C2-C3 Radical System}

\subsection{Naming the Radicals}

C1, C2, C3 refer to the consonants:
\begin{itemize}
    \item \textbf{C1}: First radical (consonant 1)
    \item \textbf{C2}: Second radical
    \item \textbf{C3}: Third radical
    \item \textbf{C4}: Fourth radical (quadriliterals only)
\end{itemize}

For \geez{ቀተለ}: C1=\geez{ቀ}, C2=\geez{ተ}, C3=\geez{ለ}

\subsection{How Templates Work}

Each conjugation form is just a vowel pattern plus optional prefix/suffix:

\begin{lstlisting}[language=Python]
# Perfective 3rd singular masculine for Type A
template = {
    "vowel_map": {"C1": 1, "C2": 1, "C3": 1},
    "prefix": "",
    "suffix": ""
}
# Result: C1(1st) + C2(1st) + C3(1st) = qä-tä-lä
\end{lstlisting}

\begin{lstlisting}[language=Python]
# Imperfective 3rd singular masculine
template = {
    "vowel_map": {"C1": 1, "C2": 6, "C3": 6},
    "prefix": "yi",
    "suffix": ""
}
# Result: yi + C1(1st) + C2(6th) + C3(6th) = yi-qä-t-l
\end{lstlisting}

\subsection{Putting It Together}

\begin{algorithm}
\caption{Generate a conjugated word}
\begin{algorithmic}[1]
\REQUIRE root (string), tense, subject, verb\_type
\ENSURE conjugated word (string)
\STATE template $\gets$ TEMPLATES[verb\_type][tense][subject]
\STATE vowel\_map $\gets$ template[``vowel\_map'']
\STATE radicals $\gets$ extract\_radicals(root)
\STATE result $\gets$ template[``prefix'']
\FOR{each position in [``C1'', ``C2'', ``C3'']}
    \STATE base $\gets$ devowelize(radicals[position])
    \STATE order $\gets$ vowel\_map[position]
    \STATE result $\gets$ result + get\_char\_by\_order(base, order)
\ENDFOR
\STATE result $\gets$ result + template[``suffix'']
\STATE result $\gets$ apply\_suffix\_fusion(result)
\RETURN result
\end{algorithmic}
\end{algorithm}

\section{Suffix Fusion Rules}

\subsection{When Suffixes Collide}

When you attach a vowel suffix to a consonant-only ending (6th order), you can't just concatenate them:

\begin{equation}
\text{C}_{6\text{th}} + \text{V}_{\text{suffix}} \rightarrow \text{C}_{\text{order}(V)}
\end{equation}

\textbf{Example}: \geez{ቅትል} + \geez{ኡ} (``they'') $\neq$ \geez{ቅትልኡ}

Instead: \geez{ቅትል} + \geez{ኡ} $\rightarrow$ \geez{ቅትሉ}

\subsection{Fusion Algorithm}

\begin{lstlisting}[language=Python]
def apply_suffix_fusion(stem, suffix):
    """Fuse 6th-order final + vowel suffix."""
    if not suffix:
        return stem
    
    last_char = stem[-1]
    last_order = get_vowel_order(last_char)
    
    # Check if stem ends in 6th order (consonant)
    if last_order != 6:
        return stem + suffix
    
    # Map suffix to target order
    suffix_vowel_map = {
        '\u12A1': 2,  # u-vowel suffix
        '\u12A0': 4,  # a-vowel suffix  
        '\u12A5': 5,  # e-vowel suffix
    }
    
    first_suffix_char = suffix[0]
    if first_suffix_char in suffix_vowel_map:
        target_order = suffix_vowel_map[first_suffix_char]
        base = devowelize(last_char)
        fused = get_char_by_order(base, target_order)
        return stem[:-1] + fused + suffix[1:]
    
    return stem + suffix
\end{lstlisting}

\section{Verb Home Detection Algorithm}

\subsection{The Eight Canonical Verb Types}

In Classical Ge'ez grammar, verbs are classified into ``homes'' (\geez{ቤት}) named after their canonical representative. EthioMorph implements all eight standard verb types:

\begin{table}[h]
\centering
\caption{The Eight Canonical Ge'ez Verb Types (Homes)}
\begin{tabular}{clll}
\toprule
\# & Type Head & Name & Description \\
\midrule
1 & \geez{ቀተለ} & Type A & Strong triradical (C1 = 1st order) \\
2 & \geez{ቀደሰ} & Type B & Geminate (C2 doubles in conjugation) \\
3 & \geez{ባረከ} & Type C & Long vowel (C1 = 4th order \geez{ራብዕ}) \\
4 & \geez{ጦመረ} & Type C-O & O-initial (C1 = 7th order \geez{ሳብዕ}) \\
5 & \geez{ሴሰየ} & Weak-Final & Final radical is \geez{የ} (weak) \\
6 & \geez{ክህለ} & Laryngeal & Contains laryngeal (\geez{ህ}) radical \\
7 & \geez{ማሕረከ} & Quadriliteral & Four consonant radicals \\
8 & \geez{ተንበለ} & T-Quad & Quadriliteral with \geez{ተ-} prefix \\
\bottomrule
\end{tabular}
\label{tab:verb_homes}
\end{table}

\subsection{How to Classify a Verb}

Each verb type uses different conjugation templates, so you need to figure out the type first. The algorithm checks:

\begin{itemize}
    \item How many radicals? (3 = triradical, 4 = quadriliteral)
    \item What vowel does C1 have? (4th order = Type C, 7th order = Type C-O)
    \item Any laryngeals (\geez{ሀ, ሐ, ኀ, አ, ዐ}) or weak consonants (\geez{ወ, የ})?
    \item Does C2 double? (That's Type B)
\end{itemize}

\begin{table}[h]
\centering
\caption{Algorithmic Classification Rules}
\begin{tabular}{lll}
\toprule
Condition & Type & Example \\
\midrule
$|\text{radicals}| \geq 4$ & Quadriliteral & \geez{ማሕረከ}, \geez{ተንበለ} \\
C1 order = 7 & Type C-O & \geez{ጦመረ} \\
C1 order = 4 & Type C & \geez{ባረከ} \\
C3 $\in$ \{weak\} & Weak-Final & \geez{ሴሰየ} \\
C2 $\in$ \{laryngeal\} & Laryngeal & \geez{ክህለ} \\
C2 geminated & Type B & \geez{ቀደሰ} \\
Default & Type A & \geez{ቀተለ} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Detection Algorithm}

\begin{algorithm}
\caption{Figure out which verb type this is}
\begin{algorithmic}[1]
\REQUIRE root (string)
\ENSURE (type, features)
\STATE radicals $\gets$ extract\_consonants(root)
\STATE features $\gets$ \{\}
\STATE // Check radical count first
\IF{len(radicals) $\geq$ 4}
    \IF{root starts with \geez{ተ}}
        \RETURN (``type\_tanbala'', features) \COMMENT{\geez{ተንበለ}}
    \ELSE
        \RETURN (``type\_mahraka'', features) \COMMENT{\geez{ማሕረከ}}
    \ENDIF
\ENDIF
\STATE // Check C1 vowel order
\STATE c1\_order $\gets$ get\_vowel\_order(root[0])
\IF{c1\_order == 7}
    \RETURN (``type\_c\_o'', features) \COMMENT{\geez{ጦመረ}}
\ELSIF{c1\_order == 4}
    \RETURN (``type\_c'', features) \COMMENT{\geez{ባረከ}}
\ENDIF
\STATE // Check for weak final radical
\IF{devowelize(root[2]) $\in$ WEAK\_CONSONANTS}
    \STATE features[``weak\_final''] $\gets$ True
    \RETURN (``type\_sesaya'', features) \COMMENT{\geez{ሴሰየ}}
\ENDIF
\STATE // Check for laryngeal radicals
\FOR{each radical in radicals}
    \IF{devowelize(radical) $\in$ LARYNGEALS}
        \STATE features[``has\_laryngeal''] $\gets$ True
        \RETURN (``type\_kahla'', features) \COMMENT{\geez{ክህለ}}
    \ENDIF
\ENDFOR
\STATE // Check for gemination (Type B)
\IF{is\_geminate\_pattern(root)}
    \RETURN (``type\_b'', features) \COMMENT{\geez{ቀደሰ}}
\ENDIF
\STATE // Default: Type A
\RETURN (``type\_a'', features) \COMMENT{\geez{ቀተለ}}
\end{algorithmic}
\end{algorithm}

\subsection{Feature Detection}

Some roots have special properties that affect conjugation:

\begin{lstlisting}[language=Python]
LARYNGEALS = {'h', 'H', 'x', 'a', 'A'}  # Gutturals
WEAK_CONSONANTS = {'w', 'y'}

def detect_features(root, radicals):
    features = {}
    
    # Check for laryngeal consonants
    for rad in radicals:
        base = devowelize(rad)
        if base in LARYNGEAL_BASES:
            features['has_laryngeal'] = True
            break
    
    # Check for hollow verb (weak C2)
    if len(radicals) >= 2:
        c2_base = devowelize(radicals[1])
        if c2_base in WEAK_BASES:
            features['is_hollow'] = True
    
    # Check for weak initial
    c1_base = devowelize(radicals[0])
    if c1_base in WEAK_BASES:
        features['weak_initial'] = True
    
    return features
\end{lstlisting}

\section{Laryngeal Vowel Shift Rules}

\subsection{Gutturals Are Picky}

Laryngeal consonants (\geez{ሀ, ሐ, ኀ, አ, ዐ}) don't accept certain vowels. When you try to apply a 1st order vowel to a laryngeal, it shifts:

\begin{equation}
\text{Laryngeal} + \text{1st order} \rightarrow \text{Laryngeal} + \text{4th order}
\end{equation}

\subsection{Implementation}

\begin{lstlisting}[language=Python]
def apply_laryngeal_rules(char, position, features):
    """Shift vowels near laryngeal consonants."""
    if not features.get('has_laryngeal'):
        return char
    
    base = devowelize(char)
    order = get_vowel_order(char)
    
    # Laryngeals prefer 4th order in jussive
    if is_laryngeal(base) and order == 1:
        return get_char_by_order(base, 4)
    
    return char
\end{lstlisting}

\section{Stemmer: Going Backwards}

The Stemmer takes a conjugated word and figures out its root. It's the reverse of generation.

\subsection{The Steps}

\begin{enumerate}
    \item Normalize spelling (Ge'ez has some redundant characters)
    \item Strip prefixes (\geez{ይ}, \geez{ተ}, \geez{አ}, etc.)
    \item Strip suffixes (\geez{ኡ}, \geez{ከ}, etc.)
    \item Get the consonant skeleton
    \item Restore any weak consonants that disappeared
    \item Figure out tense/person from what you stripped
    \item Classify the verb type
\end{enumerate}

\subsection{Checking Prefixes}

You have to check longer prefixes first, or you'll make wrong matches:

\begin{lstlisting}[language=Python]
PREFIXES = [
    # Stem IV (Causative-Passive) - check first
    'yaste', 'taste', 'naste', 'laste',
    # Stem III (Causative)
    'yas', 'tas', 'nas', 'las',
    'ya', 'ta', 'na', 'a',
    # Stem II (Passive)
    'yit', 'tit', 'te',
    # Stem I (Basic)
    'yi', 'ti', 'ni', 'li'
]
# Sorted by length descending
PREFIXES.sort(key=len, reverse=True)
\end{lstlisting}

\subsection{Pattern Identification}

\begin{lstlisting}[language=Python]
def identify_verb_pattern(stem, stripped_prefixes):
    """Determine grammatical pattern from affixes."""
    
    # Check stem markers in priority order
    if 'aste' in stripped_prefixes:
        return {'stem': 4, 'name': 'Causative-Passive'}
    
    if 'as' in stripped_prefixes or has_causative_vowel(stem):
        return {'stem': 3, 'name': 'Causative'}
    
    if 'te' in stripped_prefixes or 'yit' in stripped_prefixes:
        return {'stem': 2, 'name': 'Passive'}
    
    return {'stem': 1, 'name': 'Basic'}
\end{lstlisting}

\section{Data Structures}

\subsection{Templates JSON}

\begin{lstlisting}[language=Python]
{
  "type_a": {
    "perfective": {
      "3sm": {
        "vowel_map": {"C1": 1, "C2": 1, "C3": 1},
        "prefix": "",
        "suffix": ""
      },
      "3sf": {
        "vowel_map": {"C1": 1, "C2": 1, "C3": 4},
        "prefix": "",
        "suffix": "t"
      }
      // ... 10 person forms
    },
    "imperfective": {
      "3sm": {
        "vowel_map": {"C1": 1, "C2": 6, "C3": 6},
        "prefix": "yi",
        "suffix": ""
      }
      // ...
    }
    // jussive, imperative, derived forms
  }
}
\end{lstlisting}

\subsection{Lookup Maps}

Three precomputed dictionaries make character lookups instant:

\begin{lstlisting}[language=Python]
# Character -> Base consonant
DEVOWELIZATION_MAP = {
    '\u1240': '\u1240',  # qe -> qe (already base)
    '\u1241': '\u1240',  # qu -> qe
    '\u1242': '\u1240',  # qi -> qe
    # ... all 300+ characters
}

# Character -> Vowel order (1-7)
ORDER_MAP = {
    '\u1240': 1,  # qe = 1st order
    '\u1241': 2,  # qu = 2nd order
    # ...
}

# (Base, Order) -> Character
REVOWELIZATION_MAP = {
    ('\u1240', 1): '\u1240',
    ('\u1240', 2): '\u1241',
    ('\u1240', 3): '\u1242',
    # ...
}
\end{lstlisting}

\section{System Architecture}

\begin{figure}[h]
\centering
\begin{verbatim}
+------------------+
|    Input Word    |
+--------+---------+
         |
         v
+--------+---------+
|    Normalizer    | (homophone mapping)
+--------+---------+
         |
         v
+--------+---------+
|     Stemmer      | (analysis)
|  - Strip affixes |
|  - Extract root  |
|  - Detect pattern|
+--------+---------+
         |
         v
+--------+---------+
|   Decomposer     | (Unicode math)
|  - devowelize    |
|  - get_order     |
|  - revowelize    |
+--------+---------+
         |
         v
+--------+---------+
|   Conjugator     | (generation)
|  - Apply template|
|  - Fuse suffixes |
|  - Laryngeal adj |
+--------+---------+
         |
         v
+------------------+
|   Output Word    |
+------------------+
\end{verbatim}
\caption{How a word flows through the system}
\end{figure}

\section{API Usage}

\subsection{Analysis Endpoint}

\begin{lstlisting}
POST /api/xray
{
  "word": "yiqatlu"
}

Response:
{
  "root": "qatala",
  "pattern": "imperfective",
  "stem": 1,
  "person": "3pm",
  "verb_type": "type_a"
}
\end{lstlisting}

\subsection{Generation Endpoint}

\begin{lstlisting}
POST /api/morph
{
  "root": "qatala"
}

Response:
{
  "perfective": {
    "3sm": "qatala",
    "3sf": "qatalat",
    ...
  },
  "imperfective": {...},
  "jussive": {...}
}
\end{lstlisting}

\section{Observations}

Ge'ez morphology turns out to be more regular than expected. The Unicode trick (vowel forms are consecutive codepoints) turns what seems like a complex linguistic operation into basic arithmetic. Most of the code is just applying templates and handling edge cases for gutturals.

The system isn't complete. It handles the eight main verb types and basic stems, but there are derived forms and obscure patterns not yet implemented. Still, it works well enough to conjugate most verbs you'd encounter in classical texts.

Code: \texttt{github.com/Esubaalew/EthioMorph}

\end{document}
